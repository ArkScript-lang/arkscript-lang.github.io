.TH "Ark::State" 3 "Wed Dec 30 2020" "ArkScript" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Ark::State \- Ark state to handle the dirty job of loading and compiling ArkScript code\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <State\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBState\fP (uint16_t options=DefaultFeatures, const std::string &libdir='?') noexcept"
.br
.RI "\fIConstruct a new \fBState\fP object\&. \fP"
.ti -1c
.RI "bool \fBfeed\fP (const std::string &bytecode_filename)"
.br
.RI "\fIFeed the state by giving it the path to an existing bytecode file\&. \fP"
.ti -1c
.RI "bool \fBfeed\fP (const bytecode_t &bytecode)"
.br
.RI "\fIFeed the state with ArkScript bytecode\&. \fP"
.ti -1c
.RI "bool \fBdoFile\fP (const std::string &filename)"
.br
.RI "\fICompile a file, and use the resulting bytecode\&. \fP"
.ti -1c
.RI "bool \fBdoString\fP (const std::string &code)"
.br
.RI "\fICompile a string (representing ArkScript code) and store resulting bytecode in m_bytecode\&. \fP"
.ti -1c
.RI "void \fBloadFunction\fP (const std::string &name, internal::Value::ProcType function) noexcept"
.br
.RI "\fIRegister a function in the virtual machine\&. \fP"
.ti -1c
.RI "void \fBsetArgs\fP (const std::vector< std::string > &args) noexcept"
.br
.RI "\fISet the script arguments in sys:args\&. \fP"
.ti -1c
.RI "void \fBsetDebug\fP (unsigned level) noexcept"
.br
.RI "\fISet the debug level\&. \fP"
.ti -1c
.RI "void \fBsetLibDir\fP (const std::string &libDir) noexcept"
.br
.RI "\fISet the Lib Dir path\&. \fP"
.ti -1c
.RI "void \fBreset\fP () noexcept"
.br
.RI "\fIReset \fBState\fP (all member variables related to execution) \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBconfigure\fP ()"
.br
.RI "\fICalled to configure the state (set the bytecode, debug level, call the compiler\&.\&.\&.) \fP"
.ti -1c
.RI "bool \fBcompile\fP (unsigned debug, const std::string &file, const std::string &output, const std::string &lib_dir, uint16_t options)"
.br
.RI "\fIReads and compiles code of file\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Ark state to handle the dirty job of loading and compiling ArkScript code\&. 
.PP
Definition at line 31 of file State\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Ark::State::State (uint16_t options = \fCDefaultFeatures\fP, const std::string & libdir = \fC'?'\fP)\fC [noexcept]\fP"

.PP
Construct a new \fBState\fP object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIoptions\fP the options for the virtual machine, compiler, and parser 
.br
\fIlibdir\fP the path to the standard library, defaults to '?' which means: search in environment variables 
.RE
.PP

.PP
Definition at line 14 of file State\&.cpp\&.
.SH "Member Function Documentation"
.PP 
.SS "bool Ark::State::feed (const std::string & bytecode_filename)"

.PP
Feed the state by giving it the path to an existing bytecode file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbytecode_filename\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.PP
false on failure 
.RE
.PP

.PP
Definition at line 43 of file State\&.cpp\&.
.SS "bool Ark::State::feed (const bytecode_t & bytecode)"

.PP
Feed the state with ArkScript bytecode\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbytecode\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.PP
false on failure 
.RE
.PP

.PP
Definition at line 64 of file State\&.cpp\&.
.SS "bool Ark::State::doFile (const std::string & filename)"

.PP
Compile a file, and use the resulting bytecode\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP path to an ArkScript code file 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.PP
false on failure 
.RE
.PP

.PP
Definition at line 109 of file State\&.cpp\&.
.SS "bool Ark::State::doString (const std::string & code)"

.PP
Compile a string (representing ArkScript code) and store resulting bytecode in m_bytecode\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcode\fP the ArkScript code 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.PP
false on failure 
.RE
.PP

.PP
Definition at line 157 of file State\&.cpp\&.
.SS "void Ark::State::loadFunction (const std::string & name, internal::Value::ProcType function)\fC [noexcept]\fP"

.PP
Register a function in the virtual machine\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP the name of the function in ArkScript 
.br
\fIfunction\fP the code of the function 
.RE
.PP

.PP
Definition at line 180 of file State\&.cpp\&.
.SS "void Ark::State::setArgs (const std::vector< std::string > & args)\fC [noexcept]\fP"

.PP
Set the script arguments in sys:args\&. 
.PP
\fBParameters:\fP
.RS 4
\fIargs\fP 
.RE
.PP

.PP
Definition at line 185 of file State\&.cpp\&.
.SS "void Ark::State::setDebug (unsigned level)\fC [noexcept]\fP"

.PP
Set the debug level\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlevel\fP between 0 (nothing) and 3 (maximum verbosity) 
.RE
.PP

.PP
Definition at line 193 of file State\&.cpp\&.
.SS "void Ark::State::setLibDir (const std::string & libDir)\fC [noexcept]\fP"

.PP
Set the Lib Dir path\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlibDir\fP 
.RE
.PP

.PP
Definition at line 198 of file State\&.cpp\&.
.SS "bool Ark::State::compile (unsigned debug, const std::string & file, const std::string & output, const std::string & lib_dir, uint16_t options)\fC [private]\fP"

.PP
Reads and compiles code of file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdebug\fP set the debug level 
.br
\fIfile\fP the path of file code to compile 
.br
\fIoutput\fP set path of \&.arkc file 
.br
\fIlib_dir\fP the Lib Dir 
.br
\fIoptions\fP set vm options 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.PP
false on failure and raise an exception 
.RE
.PP

.PP
Definition at line 81 of file State\&.cpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ArkScript from the source code\&.
