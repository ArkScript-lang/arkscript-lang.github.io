.TH "Ark::VM" 3 "Wed Dec 30 2020" "ArkScript" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Ark::VM \- The ArkScript virtual machine, executing ArkScript bytecode\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <VM\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVM\fP (\fBState\fP *state) noexcept"
.br
.RI "\fIConstruct a new vm t object\&. \fP"
.ti -1c
.RI "int \fBrun\fP () noexcept"
.br
.RI "\fIRun the bytecode held in the state\&. \fP"
.ti -1c
.RI "internal::Value & \fBoperator[]\fP (const std::string &name) noexcept"
.br
.RI "\fIRetrieve a value from the virtual machine, given its symbol name\&. \fP"
.ti -1c
.RI "template<typename\&.\&.\&. Args> internal::Value \fBcall\fP (const std::string &name, Args &&\&.\&.\&.args)"
.br
.RI "\fICall a function from ArkScript, by giving it arguments\&. \fP"
.ti -1c
.RI "template<typename\&.\&.\&. Args> internal::Value \fBresolve\fP (const internal::Value *val, Args &&\&.\&.\&.args)"
.br
.RI "\fIResolving a function call (called by plugins) \fP"
.ti -1c
.RI "void \fBexit\fP (int code) noexcept"
.br
.RI "\fIAsk the \fBVM\fP to exit with a given exit code\&. \fP"
.ti -1c
.RI "void \fBsetUserPointer\fP (void *ptr) noexcept"
.br
.RI "\fISet the User Pointer object\&. \fP"
.ti -1c
.RI "void * \fBgetUserPointer\fP () noexcept"
.br
.RI "\fIRetrieves the stored pointer\&. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "int \fBsafeRun\fP (std::size_t untilFrameCount=0)"
.br
.RI "\fIRun ArkScript bytecode inside a try catch to retrieve all the exceptions and display a stack trace if needed\&. \fP"
.ti -1c
.RI "void \fBinit\fP () noexcept"
.br
.RI "\fIInitialize the \fBVM\fP according to the parameters\&. \fP"
.ti -1c
.RI "internal::Value * \fBpopAndResolveAsPtr\fP (int frame=-1)"
.br
.RI "\fIPop a value from the stack and resolve it if possible, then return it\&. \fP"
.ti -1c
.RI "internal::Value * \fBfindNearestVariable\fP (uint16_t id) noexcept"
.br
.RI "\fIFind the nearest variable of a given id\&. \fP"
.ti -1c
.RI "void \fBreturnFromFuncCall\fP ()"
.br
.RI "\fIDestroy the current frame and get back to the previous one, resuming execution\&. \fP"
.ti -1c
.RI "void \fBloadPlugin\fP (uint16_t id)"
.br
.RI "\fILoad a plugin from a constant id\&. \fP"
.ti -1c
.RI "uint16_t \fBfindNearestVariableIdWithValue\fP (internal::Value &&value) noexcept"
.br
.RI "\fIFind the nearest variable id with a given value\&. \fP"
.ti -1c
.RI "void \fBthrowVMError\fP (const std::string &message)"
.br
.RI "\fIThrow a \fBVM\fP error message\&. \fP"
.ti -1c
.RI "void \fBbacktrace\fP () noexcept"
.br
.RI "\fIDisplay a backtrace when the \fBVM\fP encounter an exception\&. \fP"
.ti -1c
.RI "void \fBcall\fP (int16_t argc_=-1)"
.br
.RI "\fIFunction called when the CALL instruction is met in the bytecode\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
The ArkScript virtual machine, executing ArkScript bytecode\&. 
.PP
Definition at line 45 of file VM\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Ark::VM::VM (\fBState\fP * state)\fC [explicit]\fP, \fC [noexcept]\fP"

.PP
Construct a new vm t object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstate\fP a pointer to an ArkScript state, which can be reused for multiple VMs 
.RE
.PP

.PP
Definition at line 29 of file VM\&.cpp\&.
.SH "Member Function Documentation"
.PP 
.SS "int Ark::VM::run ()\fC [noexcept]\fP"

.PP
Run the bytecode held in the state\&. 
.PP
\fBReturns:\fP
.RS 4
int the exit code (default to 0 if no error) 
.RE
.PP

.PP
Definition at line 190 of file VM\&.cpp\&.
.SS "internal::Value & Ark::VM::operator[] (const std::string & name)\fC [noexcept]\fP"

.PP
Retrieve a value from the virtual machine, given its symbol name\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP the name of the variable to retrieve 
.RE
.PP
\fBReturns:\fP
.RS 4
internal::Value& 
.RE
.PP

.PP
Definition at line 85 of file VM\&.cpp\&.
.SS "template<typename\&.\&.\&. Args> internal::Value Ark::VM::call (const std::string & name, Args &&\&.\&.\&. args)"

.PP
Call a function from ArkScript, by giving it arguments\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIArgs\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIname\fP the function name in the ArkScript code 
.br
\fIargs\fP C++ argument list, converted to internal representation 
.RE
.PP
\fBReturns:\fP
.RS 4
internal::Value 
.RE
.PP

.SS "template<typename\&.\&.\&. Args> internal::Value Ark::VM::resolve (const internal::Value * val, Args &&\&.\&.\&. args)"

.PP
Resolving a function call (called by plugins) 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIArgs\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIval\fP the ArkScript function object 
.br
\fIargs\fP C++ argument list 
.RE
.PP
\fBReturns:\fP
.RS 4
internal::Value 
.RE
.PP

.SS "void Ark::VM::exit (int code)\fC [noexcept]\fP"

.PP
Ask the \fBVM\fP to exit with a given exit code\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcode\fP an exit code 
.RE
.PP

.PP
Definition at line 166 of file VM\&.cpp\&.
.SS "void Ark::VM::setUserPointer (void * ptr)\fC [noexcept]\fP"

.PP
Set the User Pointer object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to data NOT owned by the \fBVM\fP, to be used later 
.RE
.PP

.PP
Definition at line 176 of file VM\&.cpp\&.
.SS "void * Ark::VM::getUserPointer ()\fC [noexcept]\fP"

.PP
Retrieves the stored pointer\&. 
.PP
\fBReturns:\fP
.RS 4
void* 
.RE
.PP

.PP
Definition at line 181 of file VM\&.cpp\&.
.SS "int Ark::VM::safeRun (std::size_t untilFrameCount = \fC0\fP)\fC [private]\fP"

.PP
Run ArkScript bytecode inside a try catch to retrieve all the exceptions and display a stack trace if needed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIuntilFrameCount\fP the frame count we need to reach before stopping the \fBVM\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
int the exit code 
.RE
.PP

.PP
Definition at line 204 of file VM\&.cpp\&.
.SS "internal::Value* Ark::VM::popAndResolveAsPtr (int frame = \fC-1\fP)\fC [inline]\fP, \fC [private]\fP"

.PP
Pop a value from the stack and resolve it if possible, then return it\&. 
.PP
\fBParameters:\fP
.RS 4
\fIframe\fP frame to pop from 
.RE
.PP
\fBReturns:\fP
.RS 4
internal::Value* 
.RE
.PP

.SS "internal::Value* Ark::VM::findNearestVariable (uint16_t id)\fC [inline]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Find the nearest variable of a given id\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP the id to find 
.RE
.PP
\fBReturns:\fP
.RS 4
internal::Value* 
.RE
.PP

.SS "void Ark::VM::returnFromFuncCall ()\fC [inline]\fP, \fC [private]\fP"

.PP
Destroy the current frame and get back to the previous one, resuming execution\&. Doing the job nobody wants to do: cleaning after everyone has finished to play\&. This is a sort of primitive garbage collector 
.SS "void Ark::VM::loadPlugin (uint16_t id)\fC [private]\fP"

.PP
Load a plugin from a constant id\&. 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP Id of the constant 
.RE
.PP

.PP
Definition at line 107 of file VM\&.cpp\&.
.SS "uint16_t Ark::VM::findNearestVariableIdWithValue (internal::Value && value)\fC [private]\fP, \fC [noexcept]\fP"

.PP
Find the nearest variable id with a given value\&. Only used to display the call stack traceback
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP the value to search for 
.RE
.PP
\fBReturns:\fP
.RS 4
uint16_t 
.RE
.PP

.PP
Definition at line 986 of file VM\&.cpp\&.
.SS "void Ark::VM::throwVMError (const std::string & message)\fC [private]\fP"

.PP
Throw a \fBVM\fP error message\&. 
.PP
\fBParameters:\fP
.RS 4
\fImessage\fP 
.RE
.PP

.PP
Definition at line 996 of file VM\&.cpp\&.
.SS "void Ark::VM::call (int16_t argc_ = \fC-1\fP)\fC [inline]\fP, \fC [private]\fP"

.PP
Function called when the CALL instruction is met in the bytecode\&. 
.PP
\fBParameters:\fP
.RS 4
\fIargc_\fP number of arguments already sent, default to -1 if it needs to search for them by itself 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for ArkScript from the source code\&.
