<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>ArkScript: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ArkScript
   </div>
   <div id="projectbrief">A small, fast, functional and scripting language for video games</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ArkScript Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the <b>implementation</b> documentation of the ArkScript programming language, if you want to contribute to it in any way.</p>
<h2>Creating modules</h2>
<p>You will still need to dive a bit into the documentation of the project, to know how:</p><ul>
<li>the VM API works, and what it provides</li>
<li>the possibilities of the Value type (comparisons, creations)</li>
<li>how to use the <code>UserType</code></li>
</ul>
<p>Also, read the https://github.com/ArkScript-lang/rfc/blob/master/004-module-error-handling.md "RFC 004" about module error handling to use the same conventions as the other modules, and the https://github.com/ArkScript-lang/rfc/blob/master/003-naming-convention.md "RFC 003" about naming conventions in ArkScript (specifically see the <em>Modules (C++)</em> section).</p>
<h2>Enhancing the project</h2>
<h3>A brief tour of the architecture of the project</h3>
<ul>
<li>everything under <code>Builtins</code> is related to builtin functions, used with the bytecode instructions <code>BUILTIN id</code><ul>
<li>adding one will need to reference it in <code><a class="el" href="_builtins_8hpp.html" title="Host the declaration of all the ArkScript builtins. ">include/Ark/Builtins/Builtins.hpp</a></code> and in <code><a class="el" href="_builtins_8cpp.html">src/Builtins/Builtins.cpp</a></code>, + implementing it accordingly under <code>src/Builtins/[file].cpp</code></li>
</ul>
</li>
<li>the Lexer, Parser, AST generation (using Nodes), AST optimizer and Compiler are located under <code>include/Ark/Compiler/</code>.<ul>
<li>the Compiler calls the Parser on a given piece of code<ul>
<li>the Parser calls the Lexer on the given code<ul>
<li>the Lexer returns a list of tokens</li>
</ul>
</li>
<li>the Parser returns an AST from the token list</li>
</ul>
</li>
<li>the Compiler calls the AST optimizer on the Parser's AST</li>
<li>the Compiler generated bytecode, which can be used as is by the virtual machine, or be saved to a file</li>
</ul>
</li>
<li>the REPL (read eval print loop) is located under <code>include/Ark/REPL/</code>. Basically it's an abstraction level over <code>replxx</code> (external library for completion and coloration in the shell) and our virtual machine to run user inputs</li>
<li>the virtual machine lies under <code>include/Ark/VM/</code> and all the folders under it<ul>
<li>it handles the Closures which capture whole Scopes through <code>shared_ptr</code>. Closures are functions with a saved scope, so they can retain information over multiple calls</li>
<li>the Plugin loader is a generic DLL / SO / DYNLIB loader, used by the virtual machine to load ArkScript modules (<code>.arkm</code> files)</li>
<li>the Scope is how we store our mapping <code>variable id =&gt; value</code>, heavily optimized for our needs</li>
<li>the State is:<ul>
<li>reading bytecode</li>
<li>decoding it</li>
<li>filling multiple tables with it (symbol table, value table, code pages), which are then used by the virtual machine. It allows us to load a single ArkScript bytecode file and use it in multiple virtual machines.</li>
<li>the State retains tables which are <b>never altered</b> by the virtual machines</li>
<li>it can also compile ArkScript code and files on the go, and run them right away</li>
</ul>
</li>
<li>the UserType is how we store C++ types unknown to our virtual machine, to use them in ArkScript code</li>
<li>the Value is a very big proxy class to a <code>variant</code> to store our types (our custom String, double, Closure, UserType and more), thus <b>it must stay small</b> because it's the primitive type of the virtual machine and the language<ul>
<li>it handles constness and type through a tag, alongside the value</li>
<li>it provides proxy functions to the underlying <code>variant</code></li>
</ul>
</li>
<li>the virtual machine handles:<ul>
<li>the stack, a single <code>array&lt;Value, 8192&gt;</code> (the stack size is a define, thus it can be changed at compile time only)</li>
<li>a pointer to the state, to read the tables and code segments</li>
<li>a pointer to a <code>void*</code> user_data, retrievable by modules and C++ user functions</li>
<li>the scopes, and their destruction</li>
<li>the instructions, executed in <code>safeRun</code> which is enclosed in a try/catch to display tracebacks when errors occur</li>
<li>external function calls through its private <code>call</code> method (to call modules' functions and builtins)</li>
<li>value resolving, useful for modules when a function receives an ArkScript function, through the public method <code>resolve</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>If you feel that this section is lacking information, please open an issue <a href="https://github.com/ArkScript-lang/Ark">on the main repository</a>.</p>
<h2>Embedding ArkScript in C++ code</h2>
<h3>Using ArkScript</h3>
<p>An example is often worth a thousands words: </p><pre class="fragment">#include &lt;Ark/Ark.hpp&gt;

int main()
{
    // A state can be shared by multiple virtual machines (note that they will NEVER modify it)
    // leave constructor empty to select the default standard library (loaded from an environment variable $ARKSCRIPT_PATH/lib)
    // persistance is needed to use vm.call(function_name, args...)
    Ark::State state(/* options */ Ark::FeaturePersist);

    // Will automatically compile the file if needed (if not, will take it from the ark cache)
    state.doFile("myfile.ark");

    Ark::VM vm(&amp;state);
    vm.run();

    /*
        If you just want to run a precompiled bytecode file:

        Ark::State state;
        state.feed("mybytecode.arkc");
        Ark::VM vm(&amp;state);
        vm.run();
    */

    /*
        To run an ArkScript function from C++ code and retrieve the result:
        we will say the code is (let foo (fun (x y) (+ x y 2)))
    */
    auto value = vm.call("foo", 5, 6.0);
    std::cout &lt;&lt; value &lt;&lt; "\n";  // displays 13

    return 0;
}
</pre><h3>Adding your own functions</h3>
<pre class="fragment">#include &lt;Ark/Ark.hpp&gt;

Ark::Value my_function(std::vector&lt;Ark::Value&gt;&amp; args, Ark::VM* vm)
{
    // checking argument number
    if (args.size() != 4)
        throw std::runtime_error("my_function needs 4 arguments!");

    auto a = args[0],
        b = args[1],
        c = args[2],
        d = args[3];

    // checking arguments type
    if (a.valueType() != Ark::ValueType::Number ||
        b.valueType() != Ark::ValueType::Number ||
        c.valueType() != Ark::ValueType::Number ||
        d.valueType() != Ark::ValueType::Number)
        throw Ark::TypeError("Type mismatch for my_function: need only numbers");

    // type is automatically deducted from the argument
    return Ark::Value(a.number() * b.number() - c.number() / d.number());
}

int main()
{
    Ark::State state(/* options */ Ark::FeaturePersist);
    state.doFile("myfile.ark");  // we can call state.doFile() before or after state.loadFunction()

    state.loadFunction("my_function", my_function);

    // we can also load C++ lambdas
    // we could have done this after creating the VM, it would still works
    // we just need to do that BEFORE we call vm.run()
    state.loadFunction("foo", [](std::vector&lt;Ark::Value&gt;&amp; args, Ark::VM* vm) {
        return Ark::Value(static_cast&lt;int&gt;(args.size()));
    });

    Ark::VM vm(&amp;state);
    vm.run();

    return 0;
}
</pre><h3>Adding your own types in ArkScript</h3>
<pre class="fragment">enum class Breakfast { Eggs, Bacon, Pizza };

Breakfast&amp; getBreakfast()
{
    static Breakfast bf = Breakfast::Pizza;
    return bf;
}

UserType::ControlFuncs* get_cfs()
{
    static UserType::ControlFuncs cfs;

    cfs.ostream_func = [](std::ostream&amp; os, const UserType&amp; a) -&gt; std::ostream&amp; {
        os &lt;&lt; "Breakfast::";
        switch (a.as&lt;Breakfast&gt;())
        {
            case Breakfast::Eggs:  os &lt;&lt; "Eggs";    break;
            case Breakfast::Bacon: os &lt;&lt; "Bacon";   break;
            case Breakfast::Pizza: os &lt;&lt; "Pizza";   break;
            default:               os &lt;&lt; "Unknown"; break;
        }
        return os;
    };

    return &amp;cfs;
}

int main()
{
    Ark::State state;

    state.loadFunction("getBreakfast", [](std::vector&lt;Ark::Value&gt;&amp; n, Ark::VM* vm) -&gt; Ark::Value {
        // we need to send the address of the object, which will be casted
        // to void* internally
        Ark::Value v = Ark::Value(Ark::UserType(&amp;getBreakfast()));

        // register the unique control functions block for this usertype
        // this cfs block can be shared between multiple usertype to reduce memory usage
        v.usertypeRef().setControlFuncs(get_cfs());

        return v;
    });

    state.loadFunction("useBreakfast", [](std::vector&lt;Ark::Value&gt;&amp; n, Ark::VM* vm) -&gt; Ark::Value {
        if (n[0].valueType() == Ark::ValueType::User &amp;&amp; n[0].usertype().is&lt;Breakfast&gt;())
        {
            std::cout &lt;&lt; "UserType detected as an enum class Breakfast" &lt;&lt; std::endl;
            Breakfast&amp; bf = n[0].usertype().as&lt;Breakfast&gt;();
            std::cout &lt;&lt; "Got " &lt;&lt; n[0].usertype() &lt;&lt; "\n";
            if (bf == Breakfast::Pizza)
                std::cout &lt;&lt; "Good choice! Have a nice breakfast ;)" &lt;&lt; std::endl;
        }

        return Ark::Nil;
    });

    state.doString("(begin (let a (getBreakfast)) (print a) (useBreakfast a))");
    Ark::VM vm(&amp;state);
    vm.run();

    /*
        Will print

        Breakfast::Pizza
        UserType detected as an enum class Breakfast
        Got Breakfast::Pizza
        Good choice! Have a nice breakfast ;)
    */

    return 0;
} </pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 13 2021 12:01:18 for ArkScript by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
